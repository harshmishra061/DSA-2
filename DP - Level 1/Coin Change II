class Solution {
    vector<vector<int>> dp;
    int change2(int idx, vector<int>& coins, int amount) {
        if(amount == 0) return 1;
        if(idx == -1) return 0;

        if(dp[idx][amount] != -1) return dp[idx][amount];

        
        int totComb = 0;
        // use curr coin
        if(amount >= coins[idx]) {
            totComb += change2(idx, coins, amount - coins[idx]);
        }
        // not use curr coin
        totComb += change2(idx - 1, coins, amount);

        return dp[idx][amount] = totComb;
    }
public:
    int change(int amount, vector<int>& coins) {
        dp.resize(coins.size(), vector<int>(amount + 1, -1));
        return change2(coins.size() - 1, coins, amount); // number of combinations possible with coins 0 to idx to make target amount
    }
};

Tabulation - 2D
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<vector<int>> dp(coins.size() + 1, vector<int>(amount + 1));

        for(int i = 0;i < dp.size();i++) {
            for(int j = 0;j < dp[0].size();j++) {
                if(j == 0) {
                    dp[i][j] = 1;
                } else if(i == 0) {
                    dp[i][j] = 0;
                } else {
                    dp[i][j] = dp[i - 1][j];
                    if(j >= coins[i - 1]) {
                        dp[i][j] = dp[i][j] > INT_MAX - dp[i][j - coins[i - 1]] ? 0 : dp[i][j] + dp[i][j - coins[i - 1]]; // JUST HANDLING THE OVERFLOW
                    }
                }
            }
        }

        return dp[coins.size()][amount];
    }
};

// Tabulation 1D
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1);
        dp[0] = 1;

        for(int i = 0;i < coins.size();i++) {
            for(int j = 0;j < dp.size();j++) {
                if(j >= coins[i]) {
                    dp[j] = dp[j] > INT_MAX - dp[j - coins[i]] ? 0 : dp[j] + dp[j - coins[i]];
                }
            }
        }

        return dp[amount];
    }
};
