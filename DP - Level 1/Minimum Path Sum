// Recursive
class Solution {
    vector<vector<int>> dp;
    int minPathSum2(int curri, int currj, int& targeti, int& targetj, vector<vector<int>>& grid) { // minimum path sum required to reach from curri,currj to targeti, targetj
        if(curri == targeti && currj == targetj) return grid[curri][currj];
        if(dp[curri][currj] != -1) return dp[curri][currj];

        // two options - go down or right
        int costOfDownMove = curri < targeti ? grid[curri][currj] + minPathSum2(curri + 1, currj, targeti, targetj, grid) : INT_MAX;// down
        int costOfRightMove = currj < targetj ? grid[curri][currj] + minPathSum2(curri, currj + 1, targeti, targetj, grid) : INT_MAX;// right

        return dp[curri][currj] = min(costOfDownMove, costOfRightMove);
    }
public:
    int minPathSum(vector<vector<int>>& grid) {
        int targeti = grid.size() - 1, targetj = grid[0].size() - 1;
        dp.resize(targeti + 1, vector<int>(targetj + 1, -1));
        return minPathSum2(0, 0, targeti, targetj, grid);
    }
};

// Tabulation
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();

        vector<vector<int>> dp(n, vector<int>(m));

        for(int i = n - 1;i >= 0;i--) {
            for(int j = m - 1;j >= 0;j--) {
                if(i == n - 1 && j == m - 1) {
                    dp[i][j] = grid[i][j];
                } else if(i == n - 1) {
                    dp[i][j] = grid[i][j] + dp[i][j + 1];
                } else if(j == m - 1) {
                    dp[i][j] = grid[i][j] + dp[i + 1][j];
                } else {
                    dp[i][j] = grid[i][j] + min(dp[i + 1][j], dp[i][j + 1]);
                }
            }
        }

        return dp[0][0];
    }
};
