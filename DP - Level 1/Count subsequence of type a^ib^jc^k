// Recursion
class Solution {
    vector<vector<int>> dp;
    int fun2(int idx, string& s, int type) {
        if(idx == -1) {
            return 0;
        }
        
        if(dp[type][idx] != -1) return dp[type][idx];
        
        if(type != (s[idx] - 'a')) return dp[type][idx] = fun2(idx - 1, s, type);
        
        if(type == 0) {
            return dp[type][idx] = (2LL * fun2(idx - 1, s, 0) + 1) % 1000000007;    
        } else if(type == 1) {
            return dp[type][idx] = (2LL * fun2(idx - 1, s, 1) + fun2(idx - 1, s, 0)) % 1000000007;
        } else if(type == 2) {
            return dp[type][idx] = (2LL * fun2(idx - 1, s, 2) + fun2(idx - 1, s, 1)) % 1000000007;
        }
        return 0;
    }
  public:
    int fun(string &s) {
        int n = s.size();
        dp.resize(3, vector<int>(n, -1));
        return fun2(n - 1, s, 2); // 2 -> return subsequence of type 2 i.e. a^i b^j c^k
                                                                type 1 i.e. a^i b^j
                                                                type 0 i.e. a^i
    }
};

// Tabulation
class Solution {
  public:
    int fun(string &s) {
        int n = s.size();
        long long MOD = 1000000007;
        long long count0 = 0, count1 = 0, count2 = 0;
        // 0 -> number of subsequences of type a^i
        // 1 -> number of subsequences of type a^i b^j
        // 2 -> number of subsequences of type a^i b^j c^k
        
        if(s[0] == 'a') count0 = 1;
        
        for(int i = 1;i < n;i++) {
            if(s[i] == 'a') {
                count0 = (2 * count0 + 1) % MOD;
            } else if(s[i] == 'b') {
                count1 = (2 * count1 + count0) % MOD;
            } else {
                count2 = (2 * count2 + count1)%MOD;
            }
        }
        
        return count2;
    }
};
